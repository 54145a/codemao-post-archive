{"id":"8632","user":{"id":"133721","nickname":"四九圣尊","avatar_url":"https://static.codemao.cn/FpwY7hm51Irx8lFHBCthzIBrYbJt","subject_id":0,"work_shop_name":"","work_shop_level":0,"wuhan_medal":false,"has_signed":false},"title":"【求助】能解释一下这个机器学习吗？","content":"<p><p><br></p>\n<p>import numpy as np # sigmoid function def nonlin(x,deriv=False): if(deriv==True): return x*(1-x) return 1/(1+np.exp(-x)) # input dataset X = np.array([ [0,0,1], [0,1,1], [1,0,1], [1,1,1] ]) # output dataset y = np.array([[0,0,1,1]]).T print() # seed random numbers to make calculation # deterministic (just a good practice) ''' np.random.seed(1) ''' # initialize weights randomly with mean 0 syn0 = 2*np.random.random((3,1)) - 1 print(syn0) for iter in range(100): # forward propagation l0 = X l1 = nonlin(np.dot(l0,syn0)) # how much did we miss? l1_error = y - l1 # multiply how much we missed by the # slope of the sigmoid at the values in l1 l1_delta = l1_error * nonlin(l1,True) # update weights syn0 += np.dot(l0.T,l1_delta) print (\"Output After Training:\") print (l1)</p>\n<p>是不是他就是先生成几个随机的数值，然后然后不断迭代他，计算他和准确值的差，</p>\n<p>l1_delta = l1_error * nonlin(l1,True) # update</p>\n<p>syn0 += np.dot(l0.T,l1_delta)</p>\n<p>这里是什么意思？他是如何调整权重的?nonlin这个代码什么意思？l1_delta是不是就是新的权重？那么np.dot(l0.T,l1_delta)他又是怎么把他更新到新的矩阵里去的呢？</p></p>","board_id":"5","board_name":"你问我答","updated_at":1516325254,"created_at":1515818924,"n_views":85,"n_replies":8,"n_comments":0,"is_authorized":false,"is_featured":false,"is_hotted":false,"is_pinned":false,"tutorial_flag":0,"ask_help_flag":0}